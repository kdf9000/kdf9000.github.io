<!doctype html>
<html lang="en-us">
  <head>
    <title>Study Notes of C // CK_D</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Dong Chengkun" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://kdf9000.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Study Notes of C"/>
<meta name="twitter:description" content="【杂项】
养成习惯： 注重格式规范，写时间，功能，目的，软件和输出结果，总结…… 看懂程序分三步： 1.流程 2.每个语句的功能 3.试数 试数原则(类似数学程序框图题)： 1.按语句执行流程进行试数 2.写整齐、详细(按循环次数分组，各环节结果均要写出) 3.试数五次之内即可看懂程序 举例： 【看懂这个1： 功能：从键盘输入一个数，判断该数是否为回文数 int val;//用val存放输入的数 int m; int sum = 0; printf (&quot;请输入待判断的数字：&quot;); scanf (&quot;%d&quot;, &amp;val); m = val; while (m) { sum = sum * 10 &#43; m % 10; m /= 10; } if (sum == val) printf (&quot;Yes&quot;); else printf (&quot;No&quot;); //sum/10以int型保存(精髓！)并巧妙地结合了C语言对真假的数字判断(精髓！)】 【看懂这个2： 功能：求斐波那契数列(n项等于n-2项与n-1项的和)的第n项 int n;//输入值 int f1, f2, f3; int i;//计数器 f1 = 1;//第n-2项 f2 = 2;//第n-1项 printf (&quot;请输入需要求的项数：&quot;); scanf (&quot;%d&quot;, &amp;n); if (1 == n) f3 = 1; else if (2 == n) f3 = 2; else for (i = 3; i &lt;= n; &#43;&#43;i) { f3 = f1 &#43; f2; f1 = f2; f2 = f3;//项数&#43;1 }//从第三项起求至第n项 printf (&quot;%d&quot;, f3);】 【看懂这个3： #include &lt;stdio."/>

    <meta property="og:title" content="Study Notes of C" />
<meta property="og:description" content="【杂项】
养成习惯： 注重格式规范，写时间，功能，目的，软件和输出结果，总结…… 看懂程序分三步： 1.流程 2.每个语句的功能 3.试数 试数原则(类似数学程序框图题)： 1.按语句执行流程进行试数 2.写整齐、详细(按循环次数分组，各环节结果均要写出) 3.试数五次之内即可看懂程序 举例： 【看懂这个1： 功能：从键盘输入一个数，判断该数是否为回文数 int val;//用val存放输入的数 int m; int sum = 0; printf (&quot;请输入待判断的数字：&quot;); scanf (&quot;%d&quot;, &amp;val); m = val; while (m) { sum = sum * 10 &#43; m % 10; m /= 10; } if (sum == val) printf (&quot;Yes&quot;); else printf (&quot;No&quot;); //sum/10以int型保存(精髓！)并巧妙地结合了C语言对真假的数字判断(精髓！)】 【看懂这个2： 功能：求斐波那契数列(n项等于n-2项与n-1项的和)的第n项 int n;//输入值 int f1, f2, f3; int i;//计数器 f1 = 1;//第n-2项 f2 = 2;//第n-1项 printf (&quot;请输入需要求的项数：&quot;); scanf (&quot;%d&quot;, &amp;n); if (1 == n) f3 = 1; else if (2 == n) f3 = 2; else for (i = 3; i &lt;= n; &#43;&#43;i) { f3 = f1 &#43; f2; f1 = f2; f2 = f3;//项数&#43;1 }//从第三项起求至第n项 printf (&quot;%d&quot;, f3);】 【看懂这个3： #include &lt;stdio." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kdf9000.github.io/post/c%E8%AF%AD%E8%A8%80%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2019-05-20T16:45:43&#43;08:00"/>
<meta property="article:modified_time" content="2019-05-20T16:45:43&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://kdf9000.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Dong Chengkun" /></a>
      <h1>CK_D</h1>
      <p>┑(￣Д ￣)┍ I love the f**king data structure</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/kdf9000"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Study Notes of C</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 20, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          21 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>【杂项】</p>

<pre><code>养成习惯：
注重格式规范，写时间，功能，目的，软件和输出结果，总结……

看懂程序分三步：
1.流程
2.每个语句的功能
3.试数
试数原则(类似数学程序框图题)：
1.按语句执行流程进行试数
2.写整齐、详细(按循环次数分组，各环节结果均要写出)
3.试数五次之内即可看懂程序

举例：
【看懂这个1：
功能：从键盘输入一个数，判断该数是否为回文数
    int val;//用val存放输入的数
    int m;
    int sum = 0;

    printf (&quot;请输入待判断的数字：&quot;);
    scanf (&quot;%d&quot;, &amp;val);

    m = val;
    while  (m)
    {
        sum = sum * 10 + m % 10;
        m /= 10;
    }
    if (sum == val)
        printf (&quot;Yes&quot;);
    else
        printf (&quot;No&quot;);
//sum/10以int型保存(精髓！)并巧妙地结合了C语言对真假的数字判断(精髓！)】

【看懂这个2：
功能：求斐波那契数列(n项等于n-2项与n-1项的和)的第n项
    int n;//输入值 
    int f1, f2, f3;
    int i;//计数器 

    f1 = 1;//第n-2项 
    f2 = 2;//第n-1项 
    printf (&quot;请输入需要求的项数：&quot;); 
    scanf (&quot;%d&quot;, &amp;n);
    if (1 == n)
        f3 = 1;
    else if (2 == n)
        f3 = 2;
    else
        for (i = 3; i &lt;= n; ++i)
        {
            f3 = f1 + f2;
            f1 = f2;
            f2 = f3;//项数+1 
        }//从第三项起求至第n项 
    printf (&quot;%d&quot;, f3);】

【看懂这个3：
#include &lt;stdio.h&gt;
int main (void)
{
    int val;
    scanf (&quot;%d&quot;, &amp;val);
    int i;
    for (i = 2; i &lt; val; ++i)
    {
        if (val % i == 0)
            break;//终止for，如执行该break则i &lt; val恒成立 
    }   //for结束后i的自增会得到保存 
    if (i == val)
        printf (&quot;yes&quot;);
    else
        printf (&quot;no&quot;);
    return 0;
}//判断一个数是否为素数】


如何掌握一个程序(如何学习需要算法的程序)(算法：解题的方法和步骤)
1.尝试自己编程解决
2.百度，按流程、功能、试数的要点看懂程序
3.自己修改程序，并且知道修改之后程序输出结果的不同
4.照答案敲代码
5.调试错误
6.不看答案独立敲出代码
7.实在不懂就背会

基本类型数据(数据类型所占字节数可能随机器不同而变化)
·整数
    整型  —— int  (4字节)
    短整型 —— short int    (8字节)
    长整型 —— long int (2字节)
·浮点数(实数)
    单精度浮点数  —— float    (4字节)
    双精度浮点数  —— double   (8字节)
·   字符  —— char (1字节)
    字符串 —— 
1字节(即1Bit)=8位。硬件能访问的最小单位是字节

复合类型数据
·枚举
·结构体

单行注释：//111
多行注释：/*111*/

变量：
本质是内存中的一段存储空间
    int i = 3;      等价于 int i; i = 3;
    int i, j;       等价于 int i; int j;
    int i, j = 3;       等价于     int i; int j; j=3;
    int i = 3, j = 5;   等价于 int i; int j; i = 3; j = 5;


进制：
    二进制             6B
    八进制6：06         6O欧
    十进制6：6          6D
    十六进制6：0x6或0X6   6H  (0~9，A~F)



输出/入控制符：    
%d  表示以十进制输出
%x或%X   表示以十六进制输出   %#x或%#X表示以十六进制并前缀0零x输出  荐使用%#X
%o  表示以八进制输出
%ld 输出long int
%f  输出float
%lf 输出double
%c  输出char
%s  表示以字符串输出    
%e  表示以科学计数法输出浮点数
%g  输出一个浮点数，指数位于[-4，5]以浮点数输出，否则以科学计数法输出

为什么需要输出控制符
1.01组成的代码可以表示数据也可以表示指令
2.同样表示数据的01代码以不同的格式输出会有不同的输出结果

常量在C语言中的表示
·整数：(看上面&quot;进制&quot;)
·浮点数：
1.传统写法  float x = 3.2;
    2.科学计数法 float x = 3.2e3;    //x的值是3200
    例：float x = 123.45e-2;  //x的值是1.2345
·字符：单个字符用单引号‘A’(否则会被当做变量名)
    字符串用双引号&quot;AB&quot;
    字符串结束的标志\0零(由系统自动添加，且不显示)

常量的存储方式：
·整数以补码的形式转化为二进制代码存储在计算机中
·浮点数以IEEE754标准转化为二进制代码存储在计算机中
·字符以ASCII码转化为整数，参照整数的存储方式
ASCII码是一种规定，它规定了各字符是以哪个整数值进行表示
/*A以65表示，a以97表示
B以66表示，b以67表示
0零以48表示*/

浮点数存储常见问题：
1.float和double都不能保证可以精确地存储一个小数
例1：如何判断浮点数x变量是否为0
    if (|x - 0.000001| &lt; 0.00001)
    是
    else
    否


例2：float i = 99.9;
    printf (&quot;%lf&quot;, i);//输出结果为99.900002
2.为什么循环中更新的变量不能定义成浮点型
【错例：
    float i;
    float sum = 0;

    for (i = 1; i &lt;= 100; i++)//自增自减即为更新
    {
        sum = sum + 1/i; 
    }
    printf (&quot;sum = %f\n&quot;, sum);
错因：i != 1，i是1的近似值，如i&lt;=1，例如i为0.99，则程序正确运行;
    如i&gt;1，例如i为1.01，则本应运行i=100的循环会因i=100.01跳出执行。】


书写规范：
1，括号成对
2，如本代码在上一条代码成立时成立，则本代码缩进，例：
if(AAA);
    while(BBB);
3，换行：按功能差别换行(功能：定义变量、对变量进行操作、输出值)

定义与赋值：
·正确：char ch = 'A';
    ch = 'C';   //先定义，后重新赋值
·错误：char ch = 'A';
    char ch = 'C’;//重复定义

基本的输入和输出函数的用法
输入：scanf( )——通过键盘将数据输入到变量中
    1用法：不含非输入控制符：scanf(&quot;输入控制符&quot; ,输入参数);  
例：int i; scanf (&quot;%d&quot;, &amp;i);  //&amp;i 表示i的地址 &amp;是取地址符，用于找变量的   地址
    功能：将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入以输入参           数的值为地址的变量中
    2用法：[不常用]含有非输入控制符：scanf(&quot;非输入控制符 输入控制符&quot;,输入参数);           例：int i; scanf(&quot;m%d&quot;,&amp;i&quot;);  //【 非输入控制符需原样输入】，如输入m123，           则实际在变量i中存入123
        3.一次给多个变量赋值：例：int i,j,k; scanf(&quot;%d %d %d&quot;,&amp;i,&amp;j,&amp;k); printf(&quot;i = %d, j          = %d, k = %d\n&quot;, i, j, k);  
            /*错例：在 int i,j,k; scanf(&quot;%d，%d，%d&quot;,&amp;i,&amp;j,&amp;k); printf(&quot;i = %d, j = %d, k = %d\n&quot;,            i, j, k); 输入1 2 3
        错因：非输入控制符需原样输入，应输入1,2,3  */
如何用scanf写出高质量代码：
1.在scanf前用printf进行标注，提示用户以何种形式进行输入
2.尽量不使用非输入控制符(逗号，空格酌情使用)，尤其不使用\n(换行符)   
//错例：scanf(“%d\n”, &amp;i);这个格式非常智障
3.[非重点]scanf对用户非法输入的处理：在一次输入中遗留的未识别的垃圾数据会在下一    次输入中进行处理，               
例：int i; scanf(&quot;%d&quot;,&amp;i);中入输入123a，则a会自动留在下一次scanf中进行处理。
处理方式：用while ((ch = getchar( )) ! = '\n') continue;等代码擦除垃圾数据
//getchar( ) 等待用户从键盘输入一个字符
4.scanf(&quot;%d%c&quot;, i, j);  %d后无空格，若输入12 q，则会将空格赋给j
scanf(&quot;%d %c&quot;, i, j);   %d后有空格，若输入12 q(无论有多少个空格)，则会将q赋给j


输出：printf( )——将变量的内容输出到显示器上
    用法：1.printf(&quot;非输入控制符\n&quot;);
        2.printf(&quot;输出控制符&quot;，输出参数)  (\n表示换行，可省略)    
例：printf(&quot;哈哈&quot;\n); printf(&quot;%d\n&quot;,i);
        3.printf(&quot;输出控制符1 输出控制符2……&quot;,输出参数1，输出参数2……);              (输出控制符和输出参数必须一一对应)
例：printf(&quot;%d %d\n&quot;， i，j)【输出控制符不含逗号，输出控制符含逗号】
        4.printf(&quot;输出控制符 非输出控制符&quot;，输出参数)

运算符：
·算数运算符
    +   -   *   /   %(取余数)
·关系运算符
    ＞   ＞=  ＜   ＜=  ！=(不等于) ==(等于)
·逻辑运算符
    ！(非)    &amp;&amp;(且)   ||(或)
·赋值运算符
    =   +=  *=  /=  -=  //a+=3等价于a=a+3
【优先级：算数＞关系＞逻辑＞赋值】
除法/的运算结果和运算对象的数据类型有关，两个数都是int，则商int，若商有小数，则舍去小数部分;被除数和除数中，只要有一个是浮点型数据，则商浮点型数据，保留小数
部分。 例：5/3==1
[不常用]取余%的运算对象必须是整数，结果是整除后的余数，余数的符号与被除数相同  例：13%-3==1    -13%-3==-3

逻辑运算符
！真  假           真||假    真               
！假  真           假||真    真               
真&amp;&amp;真    真           真||真    真       
真&amp;&amp;假    假           假||假    假       
假&amp;&amp;真    假           含真则真，同假为假   
假&amp;&amp;假    假           
同真为真，含假即假

C语言对真假的判断：非零是真，零是假
C语言对真假的表示：真用1表示，假用0零表示
【&amp;&amp;左边表达式为假时，右边表达式不执行，结果为假。例：m = (1&gt;2) &amp;&amp; (i = 5);在本例中i = 5指令不会执行】
【||左边表达式为真时，右边表达式不执行，结果为真。】
表达式：不包括分号的都是表达式，包括分号则称为语句

运算符知识补充：
自增(或自减)：
    分类：
        前自增 ——  ++i
        后自增 ——  i++
    相同点：
        最终都使i的值+1
    不同点：
        前自增整体表达式的值是i+1之后的值
        后自增整体表达式的值是i+1之前的值
    自增运算符为何存在(不用i+=1)：
        1.代码更精炼
        2.自增速度更快
    学习自增要明白的几个点：
        1.我们编程应该尽量屏蔽掉前自增和后自增的差别
        2.i++和++i最好单独成一个语句，不要作为一个完整复合语句的一部分来使用

【2错例：int m = i++ + ++i + i + i++;
    或printf (&quot;%d %d %d&quot;,i++, ++i, i);
错因：既不规范，又不可移植。
    无顺序点，即无逗括分号，不知道在语句中i的自增是否立即生效，在不同机器上执行结果可能不同】
【例(不同点)：    int i, j, k, m;

    i = j = 3;
    k = i++;
    m = ++j;

    printf (&quot;i = %d, j = %d, k =%d, m =%d&quot;, i, j, k, m);
输出结果：i==j==m==4, k = 3
i++或++i大致与i+=1相同】

三目运算符(代码量少，但逻辑不清晰，不常用)：
格式：
A ? B ： C
等价于
if (A)
B;
else
C;
例：x = (y &lt; 0) ? -y ： y;
等价于
if  (y&lt;0)
X = -y;
else
X = y;

逗号表达式：
格式：(A, B, C, D)
功能：从左到右执行
    最终表达式的值为最后一项的值
例：int i; int j = 2; i = (j++, ++j, j+2, j-3); 
printf (&quot;%d&quot;, i);  输出结果为1
例：x=(y=3,z=4,y+z*3);
    运行后，y=3  z=4  x=15

强制类型转化：
格式：
(数据类型)(表达式)
功能：
把表达式的值强制转化为前面所执行的数据类型
例子：
(int)(4.5+2.2)  最终值是    6
(float)(5)      最终值是    5.000000

预处理指令：
#include    包含
#define     宏定义
#if     如果，则预定义
#else       否则，预定义
#elif       否则如果，则预定义
#endif      结束条件判断
#ifdef      如果定义了，则
#ifndef     如果没定义，则

#include：
两种形式：
#include &lt;stdio.h&gt;到配置目录中找
#include &quot;stdio.h&quot;从当前目录开始找，无则到配置目录中找
//文件包含允许嵌套，A包含了B，B又包含了C，则B和C都会被引入文件A

#define：
宏定义，用一个标识符来表示一个字符串，这个字符串可以是常量、变量或表达式。   在宏调用中，将用该字符串替换宏名。
//非值传递，而是传递形参字符，例如传递的2是字符2不是数字2
无参数宏：
    #define PI 3.14     printf(&quot;面积为%f&quot;, PI*2*2);
    #define M (a+b+c)/2 printf(&quot;%d&quot;, M);
带参数宏：
    #define f(x) x*x+3*x
    #define Sum(a,b,c) a=b*c;b=c*a;a=b*c;
    printf(&quot;%d&quot;, 3*f(2));//没有运算优先级，结果不是30而是18

条件编译：
#if(常量表达式)//注意是常量不是变量
仅当表达式为真时，编译if与endif之间的代码
【例：
#include &lt;stdio.h&gt;
#define debug 0
#define beta 1
#define status 0

int main (void)
{
    #if (status == debug)
        printf(&quot;程序调试中&quot;);
    #elif (status == beta)
        printf(&quot;程序测试中&quot;);
    #else
        printf(&quot;ok&quot;);
    #endif
    return 0;}】

#ifdef  #ifndef
【例：
#ifndef PI
    define PI 3.14
#endif】
</code></pre>

<p>【流程控制】</p>

<pre><code>1.什么是流程控制？  是语句执行的优先级
2.流程控制的分类
·顺序
·选择
    定义：某些语句可能执行，也可能不执行，即有选择地执行
    分类：
    if ：
    格式：if (表达式)
        语句;【if表达式后不加分号】
    功能：如果表达式为真，则执行语句，如果表达式为假，则不执行语句。
    1.if最简单的用法
    2.【if的范围问题】：if默认只控制一个语句，即一个分号的内容，如果想控制多个          语句，必须用大括号将语句括起来
        例1：if (???)  printf(&quot;A\n&quot;);   printf(&quot;B\n&quot;);如???为真，则AB都输出，如???为      假，则只输出B，if内表达式真假只影响输出语句A。
        例2：if(表达式) {语句A;    语句B;}此时if可以控制大括号内的两个语句
    3.if...else...的用法//表选择，执行if后的语句或执行else后的语句，根据if后表达式真         假进行判定，if else算一个语句。【else范围参照if范围】
    4.if...else if...else...的用法：if (1) A; else if (2) B; else if (3); else D;由前往后逐一检验真假性     【如(1)(2)(3)同为真，则只执行A语句，即按顺序检验，只执行一个语句】
【不写else语句逻辑上有漏洞，但语法上正确】
【if，else if后必须接表达式，else后不能接表达式】
    5.if举例，如求分数的等级、互换两个变量的值(引入临时变量)、任意三个数字按大小        排序
switch(实质是选择而非循环)：
格式：
{
case常量表达式1：语句1;
case常量表达式2：语句2;
……
case常量表达式n：语句n;
default         ：语句n+1;
}
规则(非常次要)：
所有case后的常量表达式只能是：
(1)枚举常量
(2)数值常量
(3)字符常量
(4)常变量
(5)宏名中的一种
(6)注意普通变量和枚举变量是不能作为case后表达式的
所有switch后括号里的表达式允许为任何类型，但是vc++中只允许为int或char类型
(7)switch中出现continue是错误的，除非switch本身属于for或while的一部分
    【例：
    int (val);
    printf (&quot;请输入想到达的楼层：&quot;);
    scanf (&quot;%d&quot;, &amp;val);

    switch (val)
    {
        case 1：
            printf (&quot;一层开&quot;);
            break;
        case 2： 
            printf (&quot;二层开&quot;);
            break;
        case 3：
            printf (&quot;三层开&quot;);
            break;
        case 4：
            printf (&quot;四层开&quot;); 
            break;
        default：//默认
            printf (&quot;无&quot;);
            break; 
    }
/*switch后输入一个值找入口(case和default是入口，输入值与case后值相同则进入该case入口，否则进入default入口)，找到入口后从上往下执行(包括其他入口下的语句)，遇break结束*/】

·循环
定义：
某些代码会被重复执行
分类：
单个for：
执行顺序：
    //for循环结束后，i的自增得到了保存
//for后的三个表达式均可省略
例：for (i =0,; i&lt;4; i++) {printf(“A”}; printf(“B”);}
1.该语句循环了四次，i值分别是0、1、2、3
2.输出结果为AB交替各四次
例2：#include &lt;stdio.h&gt;
int main (void)
{
    int i ,j;
    for (i = 0, j = 7; i &lt; j, i != 2; ++i,  --j)
        printf (&quot;%d %d\n&quot;,i, j);    //输出结果：0 7  1 6

    return 0; }     //for括号内每部分可由多个表达式构成

for和if的嵌套使用：在0-100的范围之中求所有：奇数的和、奇数的个数、奇数的平                     均值、奇数和偶数各自的和(附例题)

多个for循环的嵌套使用
    for (1; 2; 3)
        for (4; 5; 6)
            A;
        B;          //3行算一个语句，23行作为一个整体算外部for的内部语句，123行算语句一,4行算语句二(与for无关)，整体是两个语句
(外for按for循环执行，把内for当做外for的第四部分。内for执行也按for循环执行，内for结束后执行外for的第三部分。)
(for循环：1→2成立→4→3→2成立→4……→2不成立→结束循环)

变式： for (1; 2; 3)
            for (4; 5; 6)
            {
                A;
                B;  
            }       //整体是一个语句，AB都在小for循环内部，执行条件相同

变式： for (7; 8; 9)
            for (1; 2; 3)
            {   A;
                B;
                for (4; 5; 6)
                C;
            }       //整体还是一个语句

while：
1.顺序：
    while(A)
        B;
    (A成立后执行B，A还成立再执行B，直到A不成立时，终止循环。)

2.与for比较：
    for与while可以相互转化,但for逻辑性更强，容易理解，不易出错。
            for (1; 2; 3)
                A;
            等价于
            1;
            while (2)
            {
                A;
                3;
            }
【while循环例：
    int i = 1;
    int sum = 0;
    while (i&lt;101)
        {
        sum = sum + i; 
        ++i;
        }   】

【for循环例：
    int i ;
    int sum = 0;
    for (i = 1; i&lt;101; i++)
    sum = sum + i;  】
3.for与while的使用场景：
    有固定循环次数或数值范围的循环用for
有明确判定界限的循环用while

do while(不常用，主要用于人机交互)
格式：
    do
    {
    A
    }
    while(B);
流程：
    先执行A，再判断B，B成立后再执行A，B不成立终止循环。
转化：
    do while 与 while 不可相互转化
    while(或for)后表达式不一定执行，但do后表达式一定执行一次
【do while的示例(求一元二次方程的解)：
    double a, b, c;
    double delta;
    double x1, x2;
    char ch;

    do
    {
        printf (&quot;请输入一元二次方程的三个系数：\n&quot;); 
        printf (&quot;a = &quot;); 
        scanf (&quot;%lf&quot;, &amp;a); 

        printf (&quot;b = &quot;); 
        scanf (&quot;%lf&quot;, &amp;b); 

        printf (&quot;c = &quot;); 
        scanf (&quot;%lf&quot;, &amp;c); 

        if (delta &gt; 0)
        {
            x1 = (-b + sqrt (delta)) / (2*a);
            x2 = (-b - sqrt (delta)) / (2*a);
            printf (&quot;有两个解， x1 = %f, x2 = %f\n&quot;, x1, x2);
        } 
        else if (delta == 0)
        {

            x1 = x2 = (-b) / (2*a);
            printf (&quot;有两个相同解，x1 = x2 = %f\n&quot;, x1, x2);
        }
        else
        { 
            printf (&quot;无实数解\n&quot;);
        }
        printf (&quot;如要继续请输入y：&quot;);
        scanf (&quot; %c&quot;, &amp;ch);             //%c前必须加空格 
    }while ('y' == ch || 'Y' == ch);    //细节：已知==未知】

【break】：
·break用于单个for循环(或switch)：
break用于终止循环和switch，【不能直接用于if】，除非if是循环内部的一个子句
格式：for (1; 2; 3)    {if (4) break;}
例：  for (int i = 0; i &lt; 5; ++i)
    {
        if (i == 3)
        break;  
        printf (&quot;%d&quot;, i);   
    }   //输出结果012
【break虽然是if内部的子句，但break终止的是外部的for循环】

·break用于多个for循环(或switch)：
【
    #include &lt;stdio.h&gt;
int main (void)
{
    int i, j;

    for  (i = 0; i &lt; 3; ++i)
    {
        for (j = 1; j &lt; 4; ++j)
            {
break;
            printf (&quot;嘿嘿！&quot;);
}   //“嘿嘿”不会输出
//此处如果添加break可以让“哈哈”不输出
        printf (&quot;哈哈\n&quot;); //“哈哈”会输出三次
    }
    return 0;
} 
在多层循环嵌套中break只能终止离它最近的循环】
【
    int x = 1, y = 0, a = 0, b = 0;
    switch (x)//第一个switch 
    {
    case 1：
        switch (y)//第二个switch 
        {
            case 0：
                a++;
                break;          //终止第二个switch
            case 1：
                b++; 
                break;
        }
//若在此对b赋值p，则最终输出结果为1 p
        break;                  //终止第一个switch
    case 2：
        a++;
        b++;
        break;
    }
    printf (&quot;%d %d\n&quot;, a, b);           //输出结果为1 0
在多层switch嵌套中，break只能终止距离它最近的switch】

continue(很少用)：
(在scanf处理输入的非法字符时用过)
功能：用于跳过本次循环余下语句，转去判断是否需要执行下次循环
格式：for (1; 2; 3)    {if (4) continue;}
例：  for (int i = 0; i &lt; 5; ++i)
    {
        if (i == 3)
        continue;   
        printf (&quot;%d&quot;, i);   
    }   //输出结果0124
【跳过了i = 3时的那次循环，直接进入i = 4的那次循环】








【27错例：
# include &lt;stdio.h&gt; 

int main (void)
{
    if (1 &gt; 2);

    {
        printf (&quot;A\n&quot;);

        printf (&quot;B\n&quot;);
    }

    return 0;
} 
错因：if表达式后不加分号，否则会形成空语句，无法控制后面的语句】

【6错例：##逻辑判断的1和0##
90&lt;=score&lt;=100
错因：90&lt;=score该逻辑判断式执行后会根据真假性得出数值0或1，无论得出何值&lt;=100都恒成立，则该表达式恒成立。
应将表达式修改为90&lt;=score &amp;&amp; score&lt;=100】

【3错例：
if (3&gt;2)
        printf (&quot;A\n&quot;)
    else
        printf (&quot;B\n&quot;);
错因：if语句与esle语句间要用分号间隔】
</code></pre>

<p>【数组】</p>

<pre><code>·为什么需要数组：
1.为解决大量同类型数据的存储和使用的问题。
2.为了模拟现实世界
·数组的分类
一维数组(线)：int a[25]; //25个元素的轴
二维数组(面)：int a[8][6]; //8行6列的面
多维数组(少见)：n维数组可以理解为每个元素是n-1维数组的一维数组，因为内存是线                性一维的，所以多维数组不存在。(103p)
·格式：
Int a[5] = {1, 2, 3, 4, 5}; //a是数组的名字，[5]表示数组元素(即变量)的个数，并且这五个                       元素分别用a[0] a[1] …… a[4]表示，a[i]表示第i+1个元素。
例：int a [5] =  {1, 2, 3, 4, 5};
int i;
for (i = 0; i &lt; 5; i++)
    printf (&quot;%d &quot;, a[i]);
//执行结果为：
1 2 3 4 5
注：1.所有元素的数据类型必须相同
2.一旦创建，不能改变大小
3.元素在内存中连续依次排列
·一维数组
怎样定义一维数组：
为n个变量连续分配储存空间
所有变量数据类型必须一致
所有变量所占字节大小必须相等
例：int a[5];

有关一维数组的操作：
1.初始化
完全初始化
int a[5] = {1, 2, 3, 4, 5};
不完全初始化【未被初始化的元素值为0】
int a[5] =  {1, 2, 3};
不初始化【所有元素都是垃圾值】
int a [5];
【错误写法1】：
int a [5];
a [5] = {1, 2, 3, 4, 5};
//错误
只有在定义数组的同时可以整体赋值
其他情况下整体赋值都是错误的
定义时[5]表示个数
其余情况下[5]表示下标
此处赋值语句中的a[5]表示a数组的第六个元素
【错误写法2】：
int a [5] = {1, 2, 3, 4, 5};
a [5] = 100;
//a [5]表示的第六元素不存在

int a [5] = {1, 2, 3, 4, 5};
int b [5];
如果要把数组a中的值全部复制给数组b
错例：b = a;
//错因：数组变量是const指针，所以不能被赋值，也就不能直接令数组b = a;
正例：for (i = 0; i &lt; 5; ++i)
b[i] = a [i];

2.赋值
int a[5];
scanf (&quot;%d&quot;, &amp;a[3]);
//给第四个元素赋值，未被赋值的元素为垃圾值

3.其他功能(如排序、插入等，多通过函数实现)(倒置101p)
注：用 sizeof(a)/sizeof(a)[0] 确认数组长度，一旦修改数组中的初始数据，不需要修改遍历的代码


·二维数组
格式：int a[3][4];/*共12个元素，可理解为三行四列，这12个元素名字依次为：
            a[0][0] a[0][1] a[0][2] a[0][3]
            a[1][0] a[1][1] a[1][2] a[1][3]
            a[2][0] a[2][1] a[2][2] a[2][3]
            a[i][j]表示第i+1行，第j+1列的元素
            a[m][n]的最末元素是a[m-1][n-1]*/
初始化：
    1.int a[3][4] = {1, 2, 3……11, 12};
    2.int a[3][4] = {
        {1, 2, 3，4}
        {5, 6, 7，8}
        {9, 10, 11，12}
        };
注：二维数组定义时可以省略行数不能省略列数，例：int a[ ] [3];
输出二维数组内容：
    int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
    int i, j;
    for (i = 0; i &lt; 3; i++)
        {
        for (j = 0; j &lt; 4; j++)
            printf(&quot;%-5d&quot;, a[i][j]); //&quot;%-5d&quot;中&quot;-&quot;表示左对齐，&quot;5&quot;表示五个空格
        printf (&quot;%\n&quot;);} //提行
【关于二维数组a[m][n]的地址】：
a[0]是一个内含两个整数的数组，
所以a[0]的值是a[0][0]的地址，
a[0]是占用1个int大小对象的地址
a是占用2个int大小对象的地址
所以a+1 != a[0]+1
但a和a[0]的值相同
①*a == a[0] == &amp;a[0][0]
②**a == *&amp;a[0][0]
③a[2][1] == *(*(a+2)+1)
</code></pre>

<p>【函数】</p>

<pre><code>为什么需要函数：
    避免了重复性操作
    有利于程序的模块化
    【例：
    #include &lt;stdio.h&gt;
    void max(int i, int j)//void表示函数没有返回值，max是函数名，i和j是形参 
    {
    if (i&gt;j)
            printf (&quot;%d\n&quot;, i);
        else
            printf (&quot;%d\n&quot;,j);
    }
    int main (void)//编程语言从main函数进入，再用函数名检测函数。void表示不接受任何参数
    {
    int a = 1;
    int b = 2;
    max(a,b);//max函数调用完毕跳回main函数后，i和j使用的内存会被释放掉
    return 0;
    }】

什么叫函数：
    逻辑上：能够完成特定功能的独立的代码块
    物理上：能够接收数据(也可以不接受)//由主调函数发往被调函数
        能够对接收的数据进行处理
        能够将数据处理的结果返回(也可以不返回任何值)//由被调函数发往主调函数
    总结：用来解决大量类似问题的工具
如何定义函数：
    函数的返回值 函数的名字 (函数的形参列表)
    {
        函数的执行体
    }
    1.函数定义的本质是详细描述函数之所以能够实现某个特定功能的具体方法
    2.【return 表达式;的含义】：
        ①终止被调函数，向主调函数返回表达式的值
        ②如果表达式为空，则只终止函数，不向主调函数返回任何值
        ③如果是void前缀的函数，则return后不能带值，只表示终止函数
        ④break是用来终止循环和switch的，return是用来终止函数的
//函数尽量出口单一，即一个函数只用一个return
    【例：
#include &lt;stdio.h&gt;
    void f (void)
    {
        int i;
        for (i = 0; i &lt; 5; ++i)
        {
            printf (&quot;A\n&quot;);
            return;//加入return后不输出B，且只输出一个A 
        }
        printf (&quot;B\n&quot;);
    }

    int main (void)
    {   
        f();

        return 10;//终止函数，并向主调函数返回10 
    }】
    3.函数返回值的类型也称函数的类型，因为如果 函数名前的返回值类型 和 函数执行体中的return 表达式;中表达式的类型不同的话，则 最终函数返回值的类型 以 函数名前的返回值类型 为准
    【例：
    #include &lt;stdio.h&gt;
    int f()
    {
        return 10.5;
    }

    int main (void)
    {
        double x = 6.6;
        x = f();
        printf (&quot;%lf\n&quot;, x);
        return 0;   
    } //因为f函数的返回值类型是int，又在主函数中以lf输出，所以程序输出10.000000而不是10.5 】
函数的分类
    有参函数 和 无参函数(括号内是否是void)
    有返回值函数 和 无返回值函数(函数类型是否为void)
    【#include &lt;stdio.h&gt;
    int f (void)//【函数括号内void】表示函数不能接收数据，int表示函数返回值是int类型数据 
    {
        return 10;//向主调(main)函数返回10 
    }
    void g (void)//【函数名前的void】表示该函数没有返回值，也不能强加return 
    {
        printf (&quot;A&quot;);
    }
int main (void)
    {
        int j = 88;
        j = f();
    printf (&quot;%d&quot;, j);
    j = g();    //因g函数没有返回值，所以该行报错
g();    //可执行，输出A
    return 0;
    }】
    库函数 和 用户自定义函数
    值传递函数和地址传递函数(不严谨，实际只有值传递函数)
    普通函数 和 主(main)函数：
        一个程序有且只有一个主函数，主函数是程序的入口和出口
        主函数可以调用普通函数，普通函数不能调用主函数(理解递归)
        普通函数可以相互调用
函数的前置声明：
    1.告诉编译器即将可能出现的若干个字母代表的是一个函数
    2.告诉编译器即将可能出现的若干个字母所代表的函数的形参和返回值的具体情况
    3.函数声明是一个语句，末尾必须加分号(声明括号内的形参名可以省略)
    4.对库函数的声明是通过#&lt;库函数所在的文件的名字.h&gt;实现的
    【错例1：
    #include &lt;stdio.h&gt;//std(标准)，i(输入)，o(输出)，h(头文件)
    void f (int);//函数声明，注意分号 

    int main (void)
    {
        f();
        return 0;
    }
    void f (void)//在声明中f函数有一个整型参数，此处f函数不接受参数，矛盾 
    {
        printf(&quot;A&quot;);
    }】
    【错例2：
    #include &lt;stdio.h&gt;

    void g (void)
    {
        f();//调用语句放在了定义语句前，且无前置声明 
    }

    void f (void)
    {
        printf(&quot;A&quot;);
    }

    int main (void)
    {
        g();
        return 0;
    }】
形参和实参：
    关系：个数相同  位置一一对应  数据类型相互兼容  但形参和实参永远是不同的变量(因为它们地址不同)
    【错例：
    #include &lt;stdio.h&gt;

    int f (int i)
    {
        int i = 99; //括号内已有i，在同一个函数内变量被重复定义 
        printf (&quot;%d&quot;, i);
        return 1;
    }

    int main (void)
    {
        int i = 10; //与被调函数中的i不冲突
        f(i);
        return 0;
    }】
【如何在软件开发中合理地设计函数来解决实际问题p115】：
    1.一个函数的功能尽量独立，单一
    2.多学习，多模仿
注意的问题：
1.函数调用时分配的内存，将在调用完毕后全部释放
    2.函数定义与函数调用的顺序
        如果函数调用写在了函数定义前，则必须在函数调用前进行声明
    【例：#include &lt;stdio.h&gt;

    void max1 (int i, int j)        //内部输出 
    {
        if (i &gt; j)
            printf (&quot;%d\n&quot;, i);
        else
            printf (&quot;%d\n&quot;, j);
    }

    int max2 (int i, int j)         //内部不输出 

    {
        if (i &gt; j)
            return i;
        else
            return j;
    }
    int main (void)
    {
        int a = 1;
        int b = 2;
        printf (&quot;%d\n&quot;, max2(a, b));    //被调函数内置于printf函数中进行处理 
        return 0;
    }】
    【例：判断一个数是否为素数
#include &lt;stdio.h&gt;

    bool IsPrime(int val)//bool类型，只有真假两个值 
    {
        int i;
        for (i = 2; i &lt; val; ++i)
        {
            if (val % i == 0)
                break;//终止for，如执行该break则i &lt; val恒成立 
        }
        if (i == val)
            return true;//终止函数 
        else
            return false;//终止函数 
    }
    int main (void)
    {
        int f;
        scanf (&quot;%d&quot;, &amp;f);
        if (IsPrime(f))//最终结果是ture或false
            printf (&quot;yes&quot;);
        else
            printf (&quot;no&quot;); 

        return 0;
    }】
变量的作用域和存储方式：
    按作用域分：
    全局变量：在所有函数(包括主函数)外部定义的变量，可在定义后的所有语句中使用
    局部变量：在一个大括号内部定义的变量(或函数的形参)，只能在本大括号内部使用
        全局变量和局部变量命名一样的问题：局部变量会屏蔽掉全局变量
            【例：
            #include &lt;stdio.h&gt;

            int i = 99;

            void f (int i)
            {
                printf (&quot;i = %d&quot;,i);
            }

            int main (void)
            {
                f(8);
                return 0;
            }//输出8，局部把全局屏蔽了】
    按存储方式分：
        静态变量
        自动变量
        寄存器变量
常用的系统函数(仅作了解)
    double sqrt(double x);   求x的平方根
    int abs (int x);   求x的绝对值
    double fabs (double x);   求x的绝对值
专题：
递归(118p)(前置知识：栈，在数据结构里讲)
</code></pre>

<p>【指针变量】</p>

<pre><code>概念：
指针=地址=内存单元(1bit)的编号
指针变量，本质还是变量，普通变量是存储的是一个值，指针变量存放的是其他变量的地址
指针和指针变量是两个不同的概念，指针是水，指针变量是杯，但我们叙述时通常会把指针变量简称为指针

格式：【int * p;//*是&amp;的逆运算(？)，int *表示p变量只能存放整型变量的地址(是存放地址不是存放变量),int *是数据类型，p是变量名，*p表示以p的内容为地址的变量(*p是p所指向的那个变量)
    int i = 3; 
    p = &amp;i;/*
        1.p保存了i的地址，因此p指向i
        2.p不是i，i也不是p，修改p的值不影响i的值，修改i的值也不影响p的值
        3.如果一个指针变量指向了某个普通变量，则 *指针变量 就完全等同于 普通变量
        例：如果p是个指针变量，并且p存放了普通变量i的地址，则p指向了普通变量i，*p就完全等同于i，在一切情况下*p和i可以互换  *p == i，*p != p
        */ 】
注：int * p, q;   //p是指针，q是整型
    【例：#include &lt;stdio.h&gt;
    int main (void)
    {
        int * p;
        int i = 3;
        int j;
        p = &amp;i;
        j = *p;
        printf (&quot;i = %d, j = %d, *p = %d&quot;,i, j, *p);
        return 0;
    }//输出结果为i = 3, j = 3, *p = 3 】
重要性：
    表示一些复杂的数据结构(树、图等)
    【快速地传递数据：指针与一维数组例1(向被调函数发送变量地址，只需要4个字节)】
    【使函数返回一个以上的值：指针与一维数组例1】
    能直接访问硬件
    能方便地处理字符串(因为字符串末尾有’\0’，所以可通过首字符地址确定字符串)
    是理解面向对象与引用的基础
    总结：是c语言的灵魂
指针的定义：
    地址：
        内存单元的编号
        从零开始的非负整数   
    指针：
        指针就是地址，地址就是指针
        指针变量就是存放内存单元编号的变量，或者说指针变量就是存放地址的变量
        指针和指针变量是两个不同的概念，但我们叙述时通常会把指针变量简称为指针
        指针的本质就是一个操作受限的非负整数(运算规则在附注中)
指针的分类：
    1.【基本类型指针】：
    【错例1：
    int * p;//*p未初始化，储存的是垃圾值，指向一个未知变量地址，可能会占用一些正在使用的重要数据，IDE有p(垃圾值)的控制权限，没有*p(p为垃圾值)的控制权限
    int i = 5;
    *p = i;//应写成p = &amp;i;
    printf (&quot;%d&quot;, * p); 】
    【错例2：
    int i = 5;
    int * p;
    int * q;
    p = &amp;i;
    *q = p;//*q是整型，p是地址，可以写成p=q并输出p，但输出结果是一个垃圾值
    printf (&quot;%d&quot;, *q);
    /*q的空间是属于本程序的，所以本程序可以读写q的内容，
    但是如果q内部是垃圾值，则本程序不能读写*q的内容
    因为*q所代表的内存单元的控制权限并没有分配给本程序
    所以本程序的输出行会报错*/】
    2.指针和数组：
    指针和一维数组：
        数组名：
            一维数组名是个指针常量，它存放的是一维数组第一个元素的地址
        下标和指针的关系：
            如果p是一个指针变量，则p[i]永远等于*(p+i)【视频缺失】        
        确定一个一维数组需要几个参数(如果一个函数要处理一个一维数组，则需要接收该数组的哪些信息)
        两个：首元素地址(确定开头)和数组长度(确定结尾)
        【例1：#include &lt;stdio.h&gt;
        void f(int* pArr, int len)//首地址要定义成指针类型
        {
            int i;
            for (i = 0; i &lt; len; ++i)
                printf (&quot;%-10d&quot;, *(pArr + i));//*(pArr+1) 等价于 pArr[i] 也等价于 b[i]  也等价于 *(b+i) 
            printf(&quot;\n&quot;);
        }   //通过指针发送首元素地址和长度，修改主函数中数组所有元素的值，等同于对主函数中的数组进行直接操作
        int main (void)
        {
            int a[5] = {1, 2, 3, 4, 5};
            int b [6]= {1, 2, 3, 4, 5, 6};
            int c [100];

            f(a, 5);//a是int *类型 
            f(b, 6);
            f(c, 100);
            return 0;
        }】
        【例2：#include &lt;stdio.h&gt;
        void f(int* pArr, int len)
        {
            pArr[3] = 88;
        }
        int main (void)
        {
            int a[6] = {1, 2, 3, 4, 5, 6};
            printf (&quot;%d\n&quot;, a[3]);//    4
            f (a, 6);   //发送元素首地址和数组长度
            printf (&quot;%d\n&quot;, a[3]);//    88      a[3] == *(a+3)
            return 0;
        }//4行的pArr[3]和9行、11行的a[3]是同一个变量，完全等价】
        指针变量的运算
    指针和二维数组：
    3.指针和函数：
    4.【指针和结构体】：
    5.多级指针(为动态分配内存做铺垫)：
【多级指针1：
#include &lt;stdio.h&gt;

int main (void)
{
    int i = 10;
    int * p = &amp;i;   //p是int *类型 
    int **q = &amp;p;   //q是int **类型，q里面不能存放int的地址，只能存放int *的地址 
    int ***r = &amp;q;  //r是int ***类型，r只能存放int**的地址，***r等价于i 

    return 0;
}】
【多级指针2
#include &lt;stdio.h&gt;

void f (int **q)
{
    Printf(“%d”, **q);//*q就是p
}

void g ()
{
    int i = 10;
    int * p = &amp;i;

    f(&amp;p);  //p是int*类型，&amp;p是int**类型 
}

int main (void)
{
    g();
    return 0;
}】
经典指针程序：
1.互换两个数字
#include &lt;stdio.h&gt;

void swap_1(int a, int b)   //不能实现互换功能 
{
    int t;
    t = a;
    a = b;
    b = t;
    return;
}

void swap_2(int * p, int * q)   //形参pq是指针变量，接收的实参应为地址
{
    int * t;    //如果要互换p和q的值，则t必须是int *类型，不能是int类型 

    t = p;
    p = q;
    q = t;
    return;
}//该函数只是将p和q的指向交换了(即p指向b，q指向a)，而不是交换地址，交换地址的操作无法实现 

void swap_3(int * p, int * q)
{
    int t;  //如果要互换*p和*q的值，则t必须是int类型，不能是int *类型 
    t = *p; //p是int *，*p是int 
    *p = *q;
    *q = t;
    return;
} 

int main (void) //要想改变主函数的值，必须发送值的地址 
{
    int a = 3;
    int b = 5;
    swap_1(a, b);
    printf (&quot;a = %d, b = %d\n&quot;, a, b);  //35
    swap_2(&amp;a, &amp;b); //此处括号内写*p， *q是错误的，写a， b也是错误的 
    printf (&quot;a = %d, b = %d\n&quot;, a, b);  //35
    swap_3(&amp;a, &amp;b);
    printf (&quot;a = %d, b = %d\n&quot;, a, b);  //53
    return 0;
}

如何通过被调函数修改主调函数普通变量的值：
    1.实参必须为该普通变量的地址
    2.形参必须为指针变量
    3.在被调函数中修改 *形参名 等价于在主调函数中修改相关变量的值
    【例：#include &lt;stdio.h&gt;

    void f (int *p, int *q) //a和p是不同的变量 
    {
        *p = 1;
        *q = 2;
    }
    int main (void)
    {
        int a = 3;
        int b = 5;
        f(&amp;a, &amp;b);
        printf(&quot;%d %d&quot;, a, b);
        return 0;
    }】

一个指针变量占几个字节(非重点)：32位系统中占4字节，64位系统中占8字节
预备知识：sizeof (数据类型) or sizeof(变量名)
        功能：返回值就是该数据类型(或变量名)所占的字节数
        例：sizeof(int) = 4
        sizeof(char) = 1
        sizeof(double) = 8
    【指向某变量的指针以该变量的首字节地址当做该变量的地址
    不同类型变量占用的字节数不同，所以必须声明指针变量的类型。】


动态内存分配(重点)：
函数：
malloc:
原型:void * malloc (unsigned int size)
//注意:返回值是void*类型，是空类型的指针，指向一个系统分配的连续的内存空间的起始地址
//接收一个无符号整数
//该函数的返回值要赋给指针，不能赋给数组，使用前要引用malloc.h头文件
作用:在内存的堆中分配一个长度为size的连续空间，若分配失败则返回NULL，要注意对NULL进行判断
【例: char *a;
    a = (char *)malloc(4 * sizeof(char));//把void*强转成了char*
    if(NULL == a) 
    {
        printf(&quot;分配失败&quot;); 
    }

    *a = 'h';
    *(a+1) = 'i';
    *(a+2) = '\n';
    *(a+3) = '\0';
    printf(a);
    free(a);】



free:
原型:void * free(void *p)
作用:释放动态内存
//有申请就必须用释放
举例:
char *a, *b;
a = (char *)malloc(10 * sizeof(char));
b = a;
free(a);//释放其指向的动态内存，指针仍然存在，此处用free(b);效果一样
【实际使用1：
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

int main (void)
{
    int i = 5;  //分配了4个字节，静态分配
    int * p = (int *)malloc(4);     //(int *)是强制类型转换，malloc后括号内的值只能为整数，用分配内存的字节数除以强制转换后变量类型的字节数可得变量个数 
    /*
        1.要使用malloc函数，必须添加malloc.h头文件
        2.malloc函数只有一个形参，并且形参是整型
        3.malloc(4)中4表示请求系统为本程序分配4个字节
        4。malloc函数只能返回第一个字节的地址 
        5.7行一共分配了8个字节，p占4个，p所指向的内存也占4个字节
        6.p本身所占的内存是静态分配的，p所指向的内存是动态分配的 
    */
    *p = 5;     //%p代表的就是一个int变量，只不过本函数中*p和i的内存分配方式不同 
    free(p);    //把p所指向的内存释放，但p本身内存不会释放 

    return 0;
}】
【实际使用2：
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void f (int * q)    //修改主函数中*p的值 
{
    //*p = 200; f内部没有p变量 
    //q =  200; error,200是整数不是地址 
    //**q = 200; q存放的是主函数中动态分配的四个字节的地址，*q就代表这四个字节，即这个整型变量，所以不能写**p
    *q = 200;
    //free(q); 把动态分配的四个字节释放了，会使19行*p失效 
}

int main (void)
{
    int * p = (int *)malloc(sizeof(int));
    *p = 10;
    printf (&quot;%d\n&quot;,*p); //10
    f(p);
    printf (&quot;%d\n&quot;,*p); //200
    return 0;
}】
传统数组的缺点【重点难点】：
    1.数组的长度必须事先指定，且只能是常整数，不能是变量。(现在已经修复)
        例：int [5];  //ok
            int len = 5; int a [len];   //error
    2.传统形式定义的数组，该数组的内存程序员无法手动释放。数组一旦定义，系统为该数组分配的空间就会一直存在，直到该数组所在的函数终止。
    3.数组的长度一旦定义，就不能再改变
    4.A函数中定义的数组，在A函数运行期间可以被其他函数调用，但A函数终止(数组内存释放)后，A函数中定义的数组将无法发送给其他函数
为什么需要动态内存分配：
    动态数组很好地解决了传统(静态)数组的4个缺陷
动态内存分配距离_动态数组的构造：
【#include &lt;stdio.h&gt;

int main (void)
{
    int a [5];  //静态，本数组共占20个字节，每4个字节被当做了一个int变量来使用

    int len;
    printf(&quot;请输入你要存放的元素个数：&quot;)
    scanf(&quot;%d&quot;, &amp;len);
    pArr = (int *)malloc(4 * len);  //动态，类似于int pArr[len]   pArr存放的动态数组的第一个字节，但pArr指向了前四个字节，所以pArr+1会指向第5至8个字节 

    for (i = 0; i &lt; len; ++i)
        scanf (&quot;%d&quot;, &amp;pArr[i]);     //对动态一维数组进行赋值 

    for (i = 0; i &lt; len; ++i)
        printf(&quot;%d\n&quot;, pArr[i]);    //对动态一维数组进行输出

    //动态缩放数组用realloc(pArr， len);函数，自己去查 
    return 0;   //本函数体现了动态数组的前三个优点
}】
静态内存和动态内存的比较(数据结构知识)：
    静态内存是由系统自动分配，由系统自动释放的的  动态内存是由程序员手动分配，手动释放的
    静态内存是在栈分配的              动态内存是在堆分配的  144p
跨函数使用内存(前置知识为多级指针)：
【静态内存不能跨函数调用：
#include &lt;stdio.h&gt;

void f(int **q)     //q是指针变量，占4个字节 
{
    int i = 5;
    *q = &amp;i;    //q存放p的地址，*q就是p，p是指针变量，要赋i的地址 
}

int main (void) 
{   
    int *p;

    f(&amp;p);

    printf (&quot;%d&quot;, *p);  //输出结果：5 
    return 0;
}   //本函数语法正确，逻辑错误，因为p所指向的i变量在f函数结束时已经被释放掉了，p只能保存i的地址，但不能访问i】
【动态内存的跨函数调用：
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void f (int **q)
{
    *q = (int *) malloc (sizeof(int));  //sizeof(数据类型)返回值是该数据类型所占的字节数
    //不同机器上整型所占字节数不同，所以此处写int比写4严谨
    **q = 5;//q存放p的地址，*q即是p，**q即是*p 
}

int main (void)
{
    int *p;
    f (&amp;p);
    printf (&quot;%d&quot;, *p); 
    return 0; }】




146p意义不明的程序1：
# include &lt;stdio.h&gt;
# include &lt;malloc.h&gt;

int main (void)
{
    int * p = (int *)malloc(4);
        /*
            malloc函数的返回值是void*
            void*也叫干地址，就是没有实际意义的地址
        */
    free(p);
    return 0; 
} 
146p意味不明的程序2：
# include &lt;stdio.h&gt;
# include &lt;malloc.h&gt;

void f (int * q)
{
    *q = 10;
}

void g (int **q)
{

}
int main (void)
{
    int * p = (int *)malloc(4);     //*p = 10
    g(&amp;p);
    printf (&quot;%d\n&quot;, *p);
    f(p);
    printf (&quot;%d\n&quot;, *p);
    return 0; 
} 

附注：
1.指针不可以相加相乘相除，但可以相减(在数组中求距离)
指针+整数=所指向地址+整数×指向类型所占的字节数(减法同理)
    例：short类型指针 1000A+1 = 1000C。
2.short[5]; *(n+2)//n[2]的值
        *n + 2//n[0]的值加2
3.指针也可指向数组后的一个位置，例如指向数组a[3]中的a[3](第四元素位置)


4.&amp;a是a的指针之一



*的用法：
1.乘法
2.定义指针变量
    int * p;//定义了一个名叫p的变量，int *表示p只能存放一个整型数据的地址
3.指针运算符，该运算符放在已经定义好的指针变量前，如果p是一个已经定义好的指针变量，则*p表示以p的内容为地址的变量
//int * p; *p = 5;   两个*的含义分别为2和3
</code></pre>

<p>【链表】</p>

<pre><code>术语：
头结点：头结点是首结点前面的那个结点，不存放有效数据，设置头结点的目的是方便
操作链表：
头指针：指向头结点的指针变量【只要确定了头指针，就能确定整个链表】
首结点：存放第一个有效数据的结点
尾结点：存放最后一个有效数据的结点，尾结点指针一般是空（NULL）
结构：结点 = 数据域 + 指针域，数据域储存该结点的有效数据，指针域储存下一结点的地址
作用:存储数据时能够不预先分配内存空间，而是在需要时动态申请内存。整个数据穿保存所需的空间可以根据需要扩大或缩小
节点结构:
1.数据域:存储数据
2.指针域:存储下一个节点元素的地址
数组与链表的比较：
数组：
优点：1.存取速度快
缺点：1.需要一整块很大的连续空间
        2.插入和删除元素的效率很低
链表：
优点：1.插入和删除元素的效率很高
2不需要整块的内存空间
缺点：1.查找某个位置的元素效率很低


【例：struct Student{
    char name [256];
    int age;
    struct Student *link};
//如果有后继的元素，则指针link指向下一个元素，若没有后继，则设置为NULL】

【静态链表:
#include &lt;stdio.h&gt;

struct Student
{
    char name [10];
    struct Student * next;
};

int main (void)
{
    struct Student s1 = {&quot;Alan&quot;, NULL};
    struct Student s2 = {&quot;Ben&quot;, NULL};
    struct Student s3 = {&quot;Coco&quot;, NULL};
    struct Student s4 = {&quot;David&quot;, NULL};    

    s1.next = &amp;s2;
    s2.next = &amp;s3;
    s3.next = &amp;s4;

    struct Student *p;
    p = &amp;s1;

    while (1)
    {
        printf(&quot;%s\n&quot;, p-&gt;name);

        if (p-&gt;next != NULL)
        {
            p = p-&gt;next;
        }
        else
        {
            break;

        }
    }
    return 0;}】

【动态链表的增删改查：
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt; 
struct Student
{
    char name [10];
    struct Student * next;
};

//链表的创建 
//头指针是malloc的，基于头指针发展出的链表是malloc的吗？？？ 
struct Student *create()
{
    struct Student *head,*current,*next;
    char str[10];
    char flag;
    printf(&quot;输入名字：&quot;);
    scanf(&quot;%s&quot;, str); 
    getchar();//擦除scanf后的非法输入，保证后面的YN判断准确执行，后同 
    head = (struct Student *)malloc(sizeof(struct Student));
    strcpy(head-&gt;name, str);

    current = head;

    printf(&quot;如不再继续请输入N：&quot;);
    scanf(&quot;%c&quot;, &amp;flag);
    while(flag != 'N')
    {
        printf(&quot;输入名字：&quot;);
        scanf(&quot;%s&quot;, str); 
        getchar();
        next = (struct Student *)malloc(sizeof(struct Student));
        strcpy(next-&gt;name, str);

        current-&gt;next = next;//上一个元素的指针指向下一个元素 
        current = next;//当前指针指向下一个元素 

        printf(&quot;如不再继续请输入N：&quot;);
        scanf(&quot;%c&quot;, &amp;flag); 

        current-&gt;next = NULL;//设最后一个元素的指针为空 
    }



    return head;
}

//链表的遍历 
void list (struct Student *p)   
{

    while (1)
    {
        printf(&quot;%s\n&quot;, p-&gt;name);

        if (p-&gt;next != NULL)
        {
            p = p-&gt;next;
        }
        else
        {
            break;

        }
    }
} 

//链表的插入
void insert (struct Student *p)
{
    struct Student *insert, *current;
    char str[10];   
    int position;
    current = p;

    printf(&quot;输入需要插入的名字：&quot;);
    scanf(&quot;%s&quot;, str); 
    getchar();

    insert = (struct Student *)malloc(sizeof(struct Student));
    strcpy(insert-&gt;name, str);

    printf(&quot;需要插入第几位之后：&quot;);
    scanf(&quot;%d&quot;, &amp;position); 

    if(position &gt; 0)
    {
        //需要插入position-1的位置 
        while(position &gt; 1)
        {
            current = current-&gt;next;
            position--;
        } 

        insert-&gt;next = current-&gt;next;//插入的元素指向当前元素的下一个 
        current-&gt;next = insert;//当前元素的下一个指向插入 的元素

    } else if(position == 9){
        //插入第一个元素的前面 
        p = insert;
        insert-&gt;next = current; 
    }

} 

//链表的删除：如欲删除节点4，则将节点3的指针指向节点5，节点4需要free掉(?) 

int main (void)
{
    struct Student *p;
    p = create();
    printf(&quot;当前的元素列表为：\n&quot;);  
    list (p);
    while(1)
    {
    insert(p); 
    printf(&quot;更新后的元素列表为：\n&quot;); 
    list(p);//遍历        
    }

    return 0;
} 】
</code></pre>

<p>【结构体】</p>

<pre><code>为什么需要结构体：
为了表示一些复杂事物，而普通的基本类型无法满足实际要求。
什么叫结构体：
结构体是用户根据实际需要，用基本数据类型复合出的新数据类型
如何定义结构体：
#include &lt;stdio.h&gt;

//1.常规定义(推荐格式)
struct Student  //没有定义变量，只是定义了一个新的数据类型  
{
int age;
float score;
char sex;
};

//2.声明的同时定义 
struct Student2 
{
int age;
float score;
char sex;
}st2;   //数据类型是struct Student2，变量名是st2

//3.匿名结构体 
struct  
{
int age;
float score;
char sex;
}st3, st4//没有分号！数据类型没有名字，变量名是st3,st4,通过变量名直接调用

//4.使用结构体作为成员
struct DATE
{
    int year;
    int month;
    int day;
};
struct person
{
    char name[256];
    struct DATE birthday;
};//把DATE结构体嵌套在person结构体内

int main (void)
{
    struct Student st = {20, 66.6, 'F'};    //struct Student相当于数据类型，st相当于变量名，                                       等号前叫结构体变量，括号内的是变量的内容
printf (&quot;%d %f %c\n&quot;, st.age, st.score, st.sex);  

    /*
    用于替代以下内容：
    int age；
    float score；
    char sex； 
    int age2；
    float score2；
    char sex2； 
    */

    return 0;
}
如何使用结构体变量：
赋值和初始化
    struct Student st = {20, 66.6, 'F'};    //在定义的同时整体赋初值
    struct Student st2; //先定义，再单个赋值 
    st2.age = 19;   
    st2.score = 99.9;
    st2.sex = 'M';
【如何操作结构体变量中的单个成员(两种方式等价)】
结构体变量名.成员名
例：st.age = 10;
指针变量名-&gt;成员名【常用】
例：struct Student * pst = &amp; st;  //定义指针，&amp;st不能写成st
pst -&gt; age = 10
//含义：pst所指向的结构体中的age成员，代表的是成员
//【pst -&gt; age在计算机内部会被转化为(*pst).age，二者等价】
结构体变量和结构体变量的指针作为函数参数传递的问题
推荐使用结构体指针变量作为参数进行传递
发送指针的优点：
快速地传递数据
耗用内存小
执行速度快
发送地址的缺点：
值有可能被更改，但可使用const让指针只读
例：
#include &lt;stdio.h&gt;
#include &lt;string.h&gt; //strcpy函数所在的头文件 
struct Student  //(三个部分共占105个字节，3个用于机器对齐，看组成原理)
{
    int age;
    char sex;
    char name [100];
};

/*
void InputStudent(struct Student stu)
{
    stu.age = 10;
    strcpy(stu.name, &quot;张三&quot;); //【要用 strcpy 字符串拷贝函数，不能写成stu.name, &quot;张三&quot;；】
    stu.sex = 'F';
}  //错的，要接收地址 

void OutputStudent(struct Student ss)   //占108个字节 
{
    printf (&quot;%d %c %s\n&quot;, ss.age, ss.sex, ss.name);
}   //不好，耗用内存多，响应速度慢 
*/

void InputStudent(struct Student *pstu) //pstu只占8个字节 
{
    (*pstu).age = 10;
    strcpy(pstu -&gt; name, &quot;张三&quot;);
    pstu -&gt; sex = 'M'; 
}

void OutputStudent(struct Student *pst) //pst只占8个字节 
{
    printf (&quot;%d %c %s\n&quot;, pst -&gt; age, pst -&gt; sex, pst -&gt; name);
}

int main (void)
{
    struct Student st;

    InputStudent(&amp;st);  //对结构体变量输入，必须发送地址 
    OutputStudent(&amp;st); //对结构体变量输出，只读不写，可以发送地址，也可以发送内容 

    return 0;
}
结构体作为参数和返回值
结构体数据类型和系统自带的数据类型一样，都可以做参数和返回值
结构体数组
就是以结构体变量为元素的数组，数组名[i]就等价于第i+1个结构体变量，所以可 以调用数组名[i].成员
结构体变量的运算
结构体变量不能相互加减乘除，但结构体变量可以相互赋值
例：
struct Student
{
(省略)
};
struct Student st1, st2;
//st1和st2不能相互加减乘除
st 1 = st 2;    //可以
前置知识：冒泡排序
冒泡排序：
#include &lt;stdio.h&gt;
void sort (int *a, int len)
{
    int i, j, t;
    for (i = 0; i &lt; len - 1; ++i)
    {
        for (j = 0; j &lt; len - 1 - i; ++j)
        {
            if (a[j] &gt; a[j+1])
            {
                t = a [j];
                a[j] = a[j+1];
                a[j+1] = t;
            }
        }
    }
}

int main (void)
{
    int a[6] = {3, 5, 9 ,234, -23, 0};
    int i = 0;

    sort (a, 6);
    for (i = 0; i &lt; 6; ++i)
        printf(&quot;%d\n&quot;, a[i]);
    return 0;
}
动态构造存放学生信息的结构体数组：
(动态构造一个数组，存放学生的信息，然后按分数升序输出)
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
struct Student
{
    int age;
    float score;
    char name[100];
};

int main (void)
{
    int len;
    struct Student * pArr;
    int i;
    struct Student t;

    printf(&quot;请输入学生的个数\n&quot;);
    printf(&quot;len = &quot;);
    scanf(&quot;%d&quot;, &amp;len);
    pArr = (struct Student *)malloc(len * sizeof(struct Student));

    //输入 
    for (i = 0; i &lt; len; ++i)
    {
        printf(&quot;请输入第%d个学生的信息\n&quot;, i+1);
        printf(&quot;年龄：&quot;);
        scanf(&quot;%d&quot;, &amp;pArr[i].age); 

        printf(&quot;姓名：&quot;);
        scanf(&quot;%s&quot;, pArr[i].name);  //name是数组名，本身是地址，不能加&amp; 

        printf(&quot;分数：&quot;);
        scanf(&quot;%f&quot;, &amp;pArr[i].score);
    }
    printf(&quot;\n\n\n\n\n&quot;);

    //按分数升序进行冒泡排序
    for (int i = 0; i &lt; len; ++i)
    {
        for (int j = 0; j &lt; len - 1 - j; ++j)
        {
            if (pArr[j].score &gt; pArr[j+1].score)
            {
                t = pArr[j];
                pArr[j] = pArr[j+1];
                pArr[j+1] = t;
            }   //交换位置，不是交换socre的值 
        }
    }

    //输出
    for (i = 0; i &lt; len; ++i)
    {
        printf(&quot;第%d个学生的信息是：\n&quot;, i+1);
        printf(&quot;年龄：%d\n&quot;, pArr[i].age);
        printf(&quot;姓名：%s\n&quot; ,pArr[i].name);
        printf(&quot;分数：%.1f\n&quot;, pArr[i].score);
    }

    return 0;}
</code></pre>

<p>【字符串】</p>

<pre><code>字符串的本质是一个以\0结尾的一维字符数组，因为以\0结尾，所以字符数组的长度比字符量多1
对于printf和scanf来说，字符串最重要的是其起始地址，如打印一个字符串:
char *text = &quot;hey peter&quot;;
1.printf(text);
2.printf(&quot;%s&quot;m text);
printf知道字符串的起始地址就会一直打印下去，遇到'\0'停止，如:
printf(&quot;Hello \0 world&quot;);只会打印出Hello 

字符串的定义与初始化
字符串字面量:
    &quot;Hello world&quot;   注:字面量是常量，不能被赋值

字符数组:
1.数组形式
    char hi[3]={'h','i','\0'};
    char hello[]={'h','e','l','l','o','\0'};
2.直接赋首地址
    char school[20]=&quot;第一中学&quot;; //形式上等价于int * j = &amp;i;
                    //用数组则申明了内存为20*sizeof(char)，可在合法内存中修改
3.省略长度
    char name1[] = &quot;Alan&quot;;
    char name2[] = {&quot;Alan&quot;};

字符指针:
char *name3 = &quot;Alan&quot;;
char *s = &quot;第一中学&quot;;   //仅为指针，不能用s修改字符串
//数组形式可读可写，指针形式只读

字符串的遍历
char hi[]=&quot;I am Tom&quot;;
1.for循环遍历
for(int i = 0; i &lt; 9; i++)
{
    printf(&quot;%c&quot;, hi[i]);
};
2.直接输出
printf(hi);
3.字符串格式输出
printf(&quot;%s&quot;, hi);

储存多个字符串:
1.二维字符数组
char name[][256] = {&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;};
2.一维指针数组
char *name[]={&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;};//数组里的每一个指针元素分别指向各个字符串的地址

常见的字符串操作函数
stdio.h
输入:scanf()  gets()  getchar()
输出:printf()  puts()  putchar()

string.h
链接:strcat()
拷贝:strcpy()
比较:strcmp()
获取长度:strlen()
大小写转换:strupr()\strlwr()
拼接字符串:sprintf()

【strcat()
原型:extern char *strcat(char *dest, const char *src);
    char hi[20]=&quot;hello&quot;;
    char *name = &quot;Tom&quot;;
    strcat(hi,name);
    printf(&quot;%s&quot;, hi);//输出结果:helloTom
//因为是把name接在hi后面，所以要保证hi是数组且有足够的空间来容纳name字符串】

【strcpy()
原型:char *strcpy(char* dest, const char *src);
    char hi[20]=&quot;hello&quot;;
    char *name = &quot;Tom&quot;;
    strcpy(hi,name);
    printf(&quot;%s&quot;, hi);//输出结果:Tom
//把hi的内容清空，再把name的内容拷贝到hi中，name中内容不受影响】

【strcmp()
原型:extern int strcmp(const char *s1,const char *s2);
    char hi[20]=&quot;hello&quot;;
    char *name = &quot;Tom&quot;;
    strcmp(hi,name);
    printf(&quot;%d\n&quot;, strcmp(hi, hi));//输出结果:0
    printf(&quot;%d\n&quot;, strcmp(hi, name));//输出结果:1 
    printf(&quot;%d\n&quot;, strcmp(name, hi));//输出结果:-1 
//注意:该函数的返回值为int
//两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇'\0'为止。
//若str1=str2，则返回零；
//若str1&lt;str2，则返回负数；
//若str1&gt;str2，则返回正数。
//注意:用strcmp做while的判断条件时，返回0(即字符串相等)，判断成立】

【strlen()
原型:extern unsigned int strlen(char *s);
    char hi[20]=&quot;hello&quot;;
    char *name = &quot;Tom&quot;;

    printf(&quot;%d\n&quot;,  strlen(hi));//输出结果:5
//注意:该函数的返回值为unsigned int
//作用是返回字符串的长度(不含'\0')
//区别于siziof()(含'\0'),sizeof()的返回值比strlen()大1】

【strupr()
原型:extern char *strupr(char *s);
    char hi[20]=&quot;helloAAA&quot;;
    char *name = &quot;Tom&quot;;

    printf(&quot;%s\n&quot;,  strupr(hi));//输出结果:HELLOAAA
//注意:因为涉及改写，所以该函数不接受字符串指针(常量)
//将字符串中所有小写字母改为大写，不改变其他字符
//strlwr()则与之相对地将大写改成小写】



【sprintf()
原型:int sprintf( char *buffer, const char *format, [argument]);
//注意:该函数的返回值为int
//buffer：char型指针，指向将要写入的字符串的缓冲区。
//format：格式化字符串。
//[argument]：可选参数，可以是任何类型的数据，可以没有这部分。
    char hi[20]=&quot;hello&quot;;
    char *name = &quot;Tom&quot;;
    char greet[20] = &quot;nice to meet you&quot;;
    char str[256];
    sprintf(str, &quot;%s %s %s&quot;, hi, name, greet);
    printf(str);//输出结果:hello Tom nice to meet you
    printf(&quot;\n&quot;);
    for(int i = 0; i &lt; 5; i++)
    {
    sprintf(str, &quot;%s%d&quot;, hi, i);
    printf(&quot;%s &quot;, str);//输出结果:hello0 hello1 hello2 hello3 hello4
    }
//把字符串和其他类型的变量拼接在一起】
</code></pre>

<p>【文件】</p>

<pre><code>fopen():
原型：FILE * fopen(const char *path, const char *mode);
//path读取文件路径，mode选择文件使用的模式
mode包括：文本文件：r\w\a\r+\w+\a+
    二进制文件：rb\wb\ab\rb+\wb+\ab+
含义：r：只读，用于向程序输入数据，要求文件已经存在，若文件不存在则返回空指针NULL
    w：只写，用于向文件输出数据，若文件已经存在则将文件删除，否则创建新的空文件
    a：追加，用于向已存在的文件追加数据，若文件不存在，则提示出错
    r+:在读的同时写
    w+:在写的同时读
//在r模式下如果文件不存在则无法打开，但在w模式下如果文件不存在会先创建文件
//若文件打开成功，fopen()函数将返回指向该文件结构体的指针，若文件打开失败，fopen()函数将返回空指针NULL
【   FILE *fp;
    char buf [SIZE] = &quot;你好，我是人工智障爱酱，很高兴见到你，嘻嘻&quot;;
    fp = fopen(&quot;C:\\Users\\user\\Desktop\\1.txt&quot;, &quot;w&quot;);

    fputs(buf, fp);

    fclose(fp);//fopen-w的强制打开
//fp为文件指针，每一个打开的文件必须对应一个单独的文件指针变量】

fclose():
原型:int fclose( FILE *fp );
将文件指针传入，释放该文件，类似free()
1.该函数用于关闭使用fopen()函数打开的文件，一般程序在之前打开了几个文件，就必须调用fclose()关闭几个文件(1.为了保护缓冲区中的数据 2.释放文件指针和读写缓冲区以打开其他文件)
2.标准设备文件stdin、stdout和stderr由系统自动打开，自动关闭
3.函数正常关闭文件后返回值为0，出错则返回符号常量EOF(值为-1)
4.若文件关闭后又想对该文件进行操作，则需再一次打开该文件

文件的读写：
单字符读写：  fgetc()     fputc()
字符串读写：  fgets()     fputs()
格式化读写：  fscanf()    fprintf()
数据块读写：  fread()     fwrite()

【fgetc()
原型:int fgetc(FILE *fp);
用法：c=fgetc(fp);//其中c和fp分别为已定义的字符变量和文件指针变量
//能从指定文件中读取一个字符，正常情况下返回读取到的字符，若读到文件尾或出错时返回EOF
//读取一个字节后，光标位置后移一个字节】

【fputc()
原型:int fputc(int c, File *fp);
//c为字符变量或常量，fp为文件指针
//能把一个字符写入到文件指针指向的文件中,正常情况下返回输出的字符，出错时返回EOF
//当正确写入一个字符或一个字节的数据后，文件内部写指针会自动后移一个字节的位置
    FILE *fp;
    char ch = 'a';
    fp = fopen(&quot;d:\\1.txt&quot;, &quot;w&quot;);

    fputc(ch, fp);

    fclose(fp);//把a写入1.txt并覆盖】

【fgets()
原型:char *fgets(char *buf, int bufsize, FILE *fp);
//buf指向保存字符串的缓存区，bufsize指明buf的大小，stream是操作的文件
//读取相应的文件，类似gets函数，一次读取一行
//如果读满一行则指针下移一行，如未读满一行则指针后移一个字符
    FILE *fp;
    char buf [20];
    fp = fopen(&quot;D:\\1.txt&quot;, &quot;r&quot;);   //斜杠是逃逸字符 

    if(NULL == fp)
    {
        printf(&quot;打开失败\n&quot;);
    }

    while(fgets(buf, 20, fp))   //返回不为空则继续打印 
    {
    printf(&quot;%s&quot;, buf);  
    }

    fclose(fp);】

【fputs()
原型:int fputs(const char *str, FILE *fp);
//会覆盖掉文件原有内容
    FILE *fp;
    char buf [20] = &quot;！\ndlrow olleh&quot;;
    fp = fopen(&quot;d:\\1.txt&quot;, &quot;w&quot;);

    if(NULL == fp)
    {
        printf(&quot;打开失败\n&quot;);
    }

    fputs(buf, fp);

    fclose(fp);】

【fseek()
原型:int fseek(FILE *stream, long offset, int fromwhere);
设置文件的位置
//stream是要操作的文件结构体，即文件流指针
//offset是偏移量
//fromwhere是偏移相对的位置
常见的位置有:SEEK_SET文件开头   SEEK_CUR当前结尾   SEEK_END文件结尾
    FILE *fp;
    char buf [20];
    fp = fopen(&quot;d:\\1.txt&quot;, &quot;r&quot;);

    if(NULL == fp)
    {
        printf(&quot;打开失败\n&quot;);
    }

    fgets(buf, 20, fp);//从第一行第一个开始读 
    printf(&quot;%s\n&quot;, buf);

    fseek(fp, 1 ,SEEK_SET); //把文件位置设置到第一行第一个后 

    fgets(buf, 20, fp); //从第一行第二个开始读 
    printf(&quot;%s\n&quot;, buf);

    fclose(fp);】

【ftell()
原型:long ftell(FILE *stream);
通过文件结构体指针获取当前指向的位置】
</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
