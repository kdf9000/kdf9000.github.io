<!doctype html>
<html lang="en-us">
  <head>
    <title>Self-study  Notes of PLAY WITH DATA STRUCTURE // CK_D</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Dong Chengkun" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="#ZgotmplZ" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Self-study  Notes of PLAY WITH DATA STRUCTURE"/>
<meta name="twitter:description" content="第一章 数据结构绪论
·基本概念和术语 数据：计算机中可以操作的对象，能被计算机识别并处理的符号集合 数据对象：性质相同的数据元素的集合，是数据的子集 数据元素：组成数据的基本单位，建立数据模型的着眼点(如人类中的人，畜类中的牛、羊) 数据项：组成数据元素的最小单位(如“人”这一数据元素中的眼耳口鼻或年龄性别等) 数据结构：相互之间存在一种或多种特定关系的数据元素的集合 ·逻辑结构与物理结构 数据结构分为逻辑结构和物理结构 逻辑结构(面向问题) 集合：数据元素同属于一个集合，之间没有其他关系 线性：数据结构是一对一关系 树形：数据结构是一对多关系 图形：数据结构是多对多关系 物理结构(面向计算机) 顺序：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的 链式：把数据元素存放在任意的存储单元里，通过指针存放的地址找到相关联的数据元素的位置 ·抽象数据类型 数据类型：一组性质相同的值的集合及定义在此集合上的一些操作的总称 抽象数据类型：一个数学模型及定义在该模型上的一组操作  第二章 算法
·算法定义 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，而且每一条指令表示一个或多个操作 ·算法的特性 输入：算法具有零个或多个输入 输出：算法至少有一个输出 有穷性：算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成 确定性：算法的每一步骤都具有确定的含义，不会出现二义性 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成 ·算法的设计要求 正确性：算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案 (一般标准：算法没有语法错误，对合法的输入数据能够产生满足要求的输出结果，对非法的输入数据能够得出满足规格说明的结果) 可读性：算法设计应当便于人们阅读、理解和交流 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果 时间效率高和存储量低：算法的执行时间应该尽可能短，需要的存储空间应该尽可能小 ·算法效率的度量方法 在分析一个程序的运算时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤 在分析一个算法的运行时间时，最重要的是基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数 即f(输入规模) = 操作次数 ·算法的时间复杂度 定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。 算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模n的增大， 算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。 其中f(n)是问题规模n的某个函数。 一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法 推导大O阶的方法： 1.用常数1取代运行时间中的所有加法常数 2.在修改后的运行次数函数中，只保留最高阶项 3.如果最高阶项存在且不是1，则去除它的系数 得到的结果就是大O阶 常数阶：对于分支结构而言，无论真假，执行的次数都是恒定的，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度也是O(1) 平方阶：循环的时间复杂度等于循环体(内层循环、函数、语句等)的复杂度乘以该循环的运行次数 对于相对复杂的语句块，应先将执行次数求和，再推导大O阶 常见时间复杂度排序(由小到大)： O(1) ＜ O(logn) ＜ O(n) ＜ O(nlogn) ＜ O(n^2) ＜ O(n^3) ＜ O(2^n) ＜ O(n!"/>

    <meta property="og:title" content="Self-study  Notes of PLAY WITH DATA STRUCTURE" />
<meta property="og:description" content="第一章 数据结构绪论
·基本概念和术语 数据：计算机中可以操作的对象，能被计算机识别并处理的符号集合 数据对象：性质相同的数据元素的集合，是数据的子集 数据元素：组成数据的基本单位，建立数据模型的着眼点(如人类中的人，畜类中的牛、羊) 数据项：组成数据元素的最小单位(如“人”这一数据元素中的眼耳口鼻或年龄性别等) 数据结构：相互之间存在一种或多种特定关系的数据元素的集合 ·逻辑结构与物理结构 数据结构分为逻辑结构和物理结构 逻辑结构(面向问题) 集合：数据元素同属于一个集合，之间没有其他关系 线性：数据结构是一对一关系 树形：数据结构是一对多关系 图形：数据结构是多对多关系 物理结构(面向计算机) 顺序：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的 链式：把数据元素存放在任意的存储单元里，通过指针存放的地址找到相关联的数据元素的位置 ·抽象数据类型 数据类型：一组性质相同的值的集合及定义在此集合上的一些操作的总称 抽象数据类型：一个数学模型及定义在该模型上的一组操作  第二章 算法
·算法定义 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，而且每一条指令表示一个或多个操作 ·算法的特性 输入：算法具有零个或多个输入 输出：算法至少有一个输出 有穷性：算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成 确定性：算法的每一步骤都具有确定的含义，不会出现二义性 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成 ·算法的设计要求 正确性：算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案 (一般标准：算法没有语法错误，对合法的输入数据能够产生满足要求的输出结果，对非法的输入数据能够得出满足规格说明的结果) 可读性：算法设计应当便于人们阅读、理解和交流 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果 时间效率高和存储量低：算法的执行时间应该尽可能短，需要的存储空间应该尽可能小 ·算法效率的度量方法 在分析一个程序的运算时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤 在分析一个算法的运行时间时，最重要的是基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数 即f(输入规模) = 操作次数 ·算法的时间复杂度 定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。 算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模n的增大， 算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。 其中f(n)是问题规模n的某个函数。 一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法 推导大O阶的方法： 1.用常数1取代运行时间中的所有加法常数 2.在修改后的运行次数函数中，只保留最高阶项 3.如果最高阶项存在且不是1，则去除它的系数 得到的结果就是大O阶 常数阶：对于分支结构而言，无论真假，执行的次数都是恒定的，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度也是O(1) 平方阶：循环的时间复杂度等于循环体(内层循环、函数、语句等)的复杂度乘以该循环的运行次数 对于相对复杂的语句块，应先将执行次数求和，再推导大O阶 常见时间复杂度排序(由小到大)： O(1) ＜ O(logn) ＜ O(n) ＜ O(nlogn) ＜ O(n^2) ＜ O(n^3) ＜ O(2^n) ＜ O(n!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="htpps://kdf9000.github.io/post/structure/" />
<meta property="article:published_time" content="2019-05-21T08:23:42&#43;08:00"/>
<meta property="article:modified_time" content="2019-05-21T08:23:42&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="htpps://kdf9000.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Dong Chengkun" /></a>
      <h1>CK_D</h1>
      <p>┑(￣Д ￣)┍ I love the f**king data structure</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/kdf9000"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Self-study  Notes of PLAY WITH DATA STRUCTURE</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 21, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>第一章 数据结构绪论</p>

<pre><code>·基本概念和术语
    数据：计算机中可以操作的对象，能被计算机识别并处理的符号集合
    数据对象：性质相同的数据元素的集合，是数据的子集
    数据元素：组成数据的基本单位，建立数据模型的着眼点(如人类中的人，畜类中的牛、羊)
    数据项：组成数据元素的最小单位(如“人”这一数据元素中的眼耳口鼻或年龄性别等)
    数据结构：相互之间存在一种或多种特定关系的数据元素的集合

·逻辑结构与物理结构
    数据结构分为逻辑结构和物理结构
    逻辑结构(面向问题)
        集合：数据元素同属于一个集合，之间没有其他关系
        线性：数据结构是一对一关系
        树形：数据结构是一对多关系
        图形：数据结构是多对多关系
    物理结构(面向计算机)
        顺序：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的
        链式：把数据元素存放在任意的存储单元里，通过指针存放的地址找到相关联的数据元素的位置

·抽象数据类型
    数据类型：一组性质相同的值的集合及定义在此集合上的一些操作的总称
    抽象数据类型：一个数学模型及定义在该模型上的一组操作
</code></pre>

<p>第二章 算法</p>

<pre><code>·算法定义
    算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，而且每一条指令表示一个或多个操作

·算法的特性
    输入：算法具有零个或多个输入
    输出：算法至少有一个输出
    有穷性：算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成
    确定性：算法的每一步骤都具有确定的含义，不会出现二义性
    可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成

·算法的设计要求
    正确性：算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案
    (一般标准：算法没有语法错误，对合法的输入数据能够产生满足要求的输出结果，对非法的输入数据能够得出满足规格说明的结果)
    可读性：算法设计应当便于人们阅读、理解和交流
    健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果
    时间效率高和存储量低：算法的执行时间应该尽可能短，需要的存储空间应该尽可能小

·算法效率的度量方法
    在分析一个程序的运算时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤
    在分析一个算法的运行时间时，最重要的是基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数
        即f(输入规模) = 操作次数

·算法的时间复杂度
    定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。
          算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模n的增大，
          算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。
          其中f(n)是问题规模n的某个函数。
    一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法
    推导大O阶的方法：
        1.用常数1取代运行时间中的所有加法常数
        2.在修改后的运行次数函数中，只保留最高阶项
        3.如果最高阶项存在且不是1，则去除它的系数
        得到的结果就是大O阶
    常数阶：对于分支结构而言，无论真假，执行的次数都是恒定的，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度也是O(1)
    平方阶：循环的时间复杂度等于循环体(内层循环、函数、语句等)的复杂度乘以该循环的运行次数
    对于相对复杂的语句块，应先将执行次数求和，再推导大O阶
    常见时间复杂度排序(由小到大)：
        O(1) ＜ O(logn) ＜ O(n) ＜ O(nlogn) ＜ O(n^2) ＜ O(n^3) ＜ O(2^n) ＜ O(n!) ＜ O(n^n)
    最坏情况与平均情况：
        最坏时间复杂度：默认讨论的，是一种保证，在应用中也是一种最重要的需求
        平均时间复杂度：所有情况中最有意义的，因为它是预期的运行时间
</code></pre>

<p>第三章 线性表</p>

<pre><code>·线性表的定义
    线性表是由零个或多个数据元素(数据类型相同)的有限序列
    当元素为零个时，称为空表
    ai是第i个数据元素，称i为数据元素ai在线性表中的位序
    在较复杂的线性表中，一个数据元素可以由若干个数据项组成

·线性表的抽象数据类型
    线性表的抽象数据类性定义如下：
        InitList(*L):初始化操作，建立一个空的线性表L
        ListEmpty(L):若线性表为空，返回ture，否则返回false
        ClearList(*L):将线性表清空
        GetElem(L, i, *e):将线性表L中第i个位置元素值返回给e
        LocateElem(L, e):在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号，否则返回0
        ListInsert(*L, i, e):在线性表L中第i个位置插入新元素e
        ListDelete(*L, i, *e):删除线性表L中第i个位置元素，并用e返回其值
        ListLength(L):返回线性表L的元素个数
    对于实际问题中涉及的关于线性表的更复杂的操作，完全可以用这些基本操作的组合来实现

·线性表的顺序存储结构
    定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素(常用一维数组实现)
    描述顺序存储结构需要三个属性：
        存储空间的起始位置
        线性表的最大存储容量(存放线性表的存储空间的长度，一般是固定的，且大于线性表的当前长度)
        线性表的当前长度(线性表中数据元素的个数，随着线性表的插入和删除而改变)
    (地址的计算方法同于C语言中数组地址的计算方法，此处略去)
    对于顺序存储结构的存入或读取，时间复杂度都是O(1)

·顺序存储结构的插入与删除
    插入算法的思路：
        如果插入位置不合理，抛出异常；
        如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
        从最后后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；
        将要插入的元素填入位置i处；
        表长+1；
    删除算法的思路：
        如果删除位置不正确，抛出异常；
        取出删除元素；
        从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
        表长-1；
    对于顺序存储结构的插入或删除，时间复杂度都是O(n)
    线性表的顺序存储结构优缺点如下：
        优点：
            1.无需为表示元素的逻辑关系而额外增加存储空间
            2.可以快速地存取表中任一位置的数据
        缺点：
            1.插入和删除操作需要移动大量元素
            2.当线性表长度变化较大时，难以确定存储空间的容量
            3.造成存储空间的“碎片”

·线性表的链式存储结构
    线性表的链式存储结构定义：
        对于数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。存储数据元素信息的域称为数据域，存储直接后继位置的域称为指针域，指针域中存储的信息称作指针或链。这两部分信息组成的数据元素ai的存储映像称为结点(Node)。
        每个结点中只包含一个指针域的链表称作单链表。
        链表中第一个结点的储存位置称作头指针，整个链表的存取必须从头指针开始进行。
        线性链表的最后一个结点为NULL。
        在单链表的第一个结点前附设一个结点，称为头结点。头结点可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。
    头指针与头结点的异同：
        头指针：
            头指针是指链表指向第一个结点(如头结点存在则为头结点)的指针。
            头指针具有标识作用，所以常用头指针冠以链表的名字。
            无论链表是否为空，头指针均不为空，头指针是链表的必要元素。
        头结点：
            头结点的数据域一般无意义。
            有了头结点，对第一个元素结点的操作就得到了简化。
            头结点不是链表的必要元素。
    (对链表的操作与C语言中相同，不赘述)

·单链表的读取
    获得链表第i个数据的算法思路：
        声明一个指针p指向链表的第一个结点，初始化j从1开始；
        当j&lt;i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；
        若到链表末尾p为空，则说明第i个结点不存在；
        否则查找成功，返回结点p的数据；
    上述操作的时间复杂度是O(n)
    其核心思想是“工作指针后移”，这是很多算法的常用技术。

·单链表的插入与删除
    单链表的插入：
        s-&gt;next=p-&gt;next; p-&gt;next=s;
        如果要将结点s插入到结点p和p-&gt;next之间，则需使用如上标准语句
        注意：上述代码顺序不可交换，否则操作失败
    单链表第i个数据插入结点的算法思路：
        声明一个指针p指向链表的头结点，初始化j从1开始；
        当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
        若到链表末尾p为空，则说明第i个结点不存在；
        否则查找成功，在系统中生成一个空结点s；
        将数据元素e赋值给s-&gt;data；
        单链表的插入标准语句 s-&gt;next=p-&gt;next;  p-&gt;next=s;
        返回成功；
    单链表的删除：
        q=p-&gt;next; p-&gt;next=q-&gt;next;
        如果要将结点p-&gt;next从结点p和p-&gt;next-&gt;next之间删除，则需使用如上标准语句
        单链表第i个数据删除结点的算法思路：
        声明一个指针p指向链表头指针，初始化j从1开始；
        当j&lt;i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；
        若到链表末尾p为空，则说明第i个结点不存在；
        否则查找成功，将欲删除的结点p-&gt;next赋值给q；
        单链表的删除标准语句p-&gt;next=q-&gt;next;
        将q结点中的数据赋值给e，作为返回；
        释放q结点；
        返回成功；
    单链表的插入与删除操作，时间复杂度都是O(n)，但如果，我们希望在第i个位置插入多个结点，对于顺序结构而言，每一次插入都需要移动n-i个结点，每次都是O(n)，但对单链表而言，只有在第一次操作(即确定i的位置)时是O(n)，接下来都是O(1)。显然，对于插入或删除越频繁的操作，单链表的效率优势就越明显。

·单链表的整表创建
    单链表的整表创建算法思路(头插法)：
        声明一指针p和计数器变量i；
        初始化一空链表L；
        让L的头结点的指针指向NULL，即建立一个带头结点的单链表；
        循环：
            生成一新结点赋值给p；
            随机生成一数字赋值给p的数据域p-&gt;data；
            将p插入到头结点与新节点之间；(尾插法则将p插入到链表末尾)

·单链表的整表删除
    单链表的整表删除算法思路：
        声明结点p和q；
        将第一个结点赋值给p；
        循环：
            将下一个结点赋值给q；
            释放p；
            将q赋值给p；

·单链表结构与顺序存储结构的优缺点
    存储分配方式：
        顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
        单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
    时间性能：
        查找：
            顺序存储结构O(1)
            单链表O(n)
        插入和删除：
            顺序存储结构O(n)
            单链表O(1)          但查找出需要的位置为O(n)
    空间性能：
        顺序存储结构容易出现空间浪费或溢出的情况
        单链表的空间分配更加灵活
    总结：
        若需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构，反之采用单链表结构
        若线性表中的元素个数变化过大或根本不确定时，宜采用单链表结构，反之采用顺序存储结构

·静态链表(P71—77，一般用不上)

·循环链表
    含义：
        将单链表中终端结点的指针域由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。
        循环链表与单链表的主要差异在于循环的判断条件，单链表是p-&gt;next为空则结束，循环链表是判断p-&gt;next为头结点则结束。不过对于循环链表而言，头结点也并不是必须的。
        引入指向终端结点的尾指针rear，则查找终端结点是O(1)，而不是通过头指针查找终端结点的O(n)，通过尾指针查找开始结点，即rear-&gt;next-&gt;next，也是O(1)。
    如需将A链表与B链表合并(A的终端结点指向B的开始结点)，则需如下算法思路：
        用指针p保存A链表终端结点的指针域；
        用A链表终端结点的指针域保存B链表的开始结点；
        用指针q保存B链表终端结点的指针域；
        用B链表终端结点的指针域指向A链表的头结点；
        释放指针q(即释放B链表的头结点)；

·双向链表
    含义：
        双向链表中的结点都有两个指针域，一个指向直接后继，一个指向直接前驱。
        双向链表是单链表中拓展出来的结构，很多操作和单链表是相同的，而且只涉及一个方向的指针，另一个指针不能提供帮助。但在结点插入和删除时，需要修改两个指针变量。
    要将结点s插入到结点p和p-&gt;next之间，需要如下标准语句：
        s-&gt;prior=p;  //把p赋值给s的前驱
        s-&gt;next=p-&gt;next;  //把p-&gt;next赋值给s的后继
        p-next-&gt;prior=s;  //把s赋值给p-&gt;next的前驱
        P-&gt;next=s;  //把s赋值给p的后继
    注意：顺序不可以变更
    要删除结点p，则需要如下标准语句：
        p-&gt;prior-&gt;next=p-&gt;next;  //把p-&gt;next赋值给p-&gt;prior的后继
        p-&gt;next-&gt;prior=p-&gt;prior;  //把p-&gt;prior赋值给p-&gt;next的前驱
        free(p);  //释放p
    双向链表由于其优秀的对称性，使得对某个结点前后结点的操作更加便利，但多了prior指针，对插入和删除来说会更加复杂。
</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
